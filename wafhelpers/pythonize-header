#!/usr/bin/env python
"""
Generate a C Python module from a C file of macro definitions.

Uses simple regexp transformations, so weird headers are likely to confuse it.
Skips #include lines, struct and union declarations.  Transforms comments.
Does not yet handle externs.
"""

import sys, re

patterns = (
    (re.compile(r"/\*(.*)\*/"), r"#\1"),
    (re.compile(r"^/\*"), r"#"),
    (re.compile(r"^ *\*/"), r"#"),
    (re.compile(r"^ \*"), r"#"),
    (re.compile(r"^#define\s+([A-Z0-9_]+\s+)(.*)"), r"\1= \2"), 
    (re.compile(r"^#define\s+([A-Z0-9_]+)\(([a-z_, ]*)\)"),
     r"def \1(\2): return"), 
    )

skipstarters = ("struct", "union", "typedef struct", "typedef union")

impossibles = ("sizeof", "offsetof")

def pythonize(rfp, wfp):
    "Pythonize a specified C header file."
    wfp.write("# This file was generated by pythonize-header;\n")
    wfp.write("# DO NOT HAND-HACK IT!\n")
    skipto = False
    for line in rfp:
        # Omit include lines
        if line.startswith("#include"):
            continue
        # Omit structure and union declarations
        for skipstart in skipstarters:
            if line.startswith(skipstart):
                skipto = True
                break
        if line.startswith("};"):
            skipto = False
            continue
        # Hack remaining content
        for (regexp, replacement) in patterns:
            line = regexp.sub(replacement, line)
        # Omit some expression elents Python cannot evaluate
        for word in impossibles:
            if word in line:
                line = "# " + line
        # We're done
        if not skipto:
            wfp.write(line)

if __name__ == '__main__':
    if len(sys.argv) == 1:
        pythonize(sys.stdin, sys.stdout)
    else:
        for path in sys.argv[1:]:
            with open(path) as rfp:
                sys.stdout.write("#\n# Definitions from %s begin\n#\n" % path)
                pythonize(rfp, sys.stdout)
