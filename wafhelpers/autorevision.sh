#!/bin/sh

# Note! This version has been locally modified!
# The "VCS_" prefix on symbols has been removed, and EXTRA has become VERSION

# Copyright (c) 2012 - 2016 dak180 and contributors. See
# https://opensource.org/licenses/mit-license.php or the included
# COPYING.md for licence terms.
#
# autorevision - extracts metadata about the head version from your
# repository.

# Usage message.
arUsage() {
	cat > "/dev/stderr" << EOF
usage: autorevision {-t output-type | -s symbol} [-o cache-file [-f] ] [-V]
	Options include:
	-t output-type		= specify output type
	-s symbol		= specify symbol output
	-o cache-file		= specify cache file location
	-f			= force the use of cache data
	-U			= check for untracked files in svn
	-V			= emit version and exit
	-?			= help message

The following are valid output types:
	clojure			= clojure file
	c			= C/C++ file
	h			= Header for use with c/c++
	hpp			= Alternate C++ header strings with namespace
	ini			= INI file
	java			= Java file
	javaprop		= Java properties file
	js			= javascript file
	json			= JSON file
	lua			= Lua file
	m4			= m4 file
	matlab			= matlab file
	octave			= octave file
	php			= PHP file
	pl			= Perl file
	py			= Python file
	rpm			= rpm file
	scheme			= scheme file
	sh			= Bash sytax
	swift			= Swift file
	tex			= (La)TeX file
	xcode			= Header useful for populating info.plist files


The following are valid symbols:
	TYPE
	BASENAME
	UUID
	NUM
	DATE
	BRANCH
	TAG
	TICK
	VERSION
	FULL_HASH
	SHORT_HASH
	WC_MODIFIED
	ACTION_STAMP
EOF
	exit 1
}

# Config
ARVERSION="&&ARVERSION&&"
TARGETFILE="/dev/stdout"
while getopts ":t:o:s:VfU" OPTION; do
	case "${OPTION}" in
		t)
			AFILETYPE="${OPTARG}"
		;;
		o)
			CACHEFILE="${OPTARG}"
		;;
		f)
			CACHEFORCE="1"
		;;
		s)
			VAROUT="${OPTARG}"
		;;
		U)
			UNTRACKEDFILES="1"
		;;
		V)
			echo "autorevision ${ARVERSION}"
			exit 0
		;;
		?)
			# If an unknown flag is used (or -?):
			arUsage
		;;
	esac
done

if [ ! -z "${VAROUT}" ] && [ ! -z "${AFILETYPE}" ]; then
	# If both -s and -t are specified:
	echo "error: Improper argument combination." 1>&2
	exit 1
elif [ -z "${VAROUT}" ] && [ -z "${AFILETYPE}" ]; then
	# If neither -s or -t are specified:
	arUsage
elif [ -z "${CACHEFILE}" ] && [ "${CACHEFORCE}" = "1" ]; then
	# If -f is specified without -o:
	arUsage
elif [ ! -f "${CACHEFILE}" ] && [ "${CACHEFORCE}" = "1" ]; then
	# If we are forced to use the cache but it does not exist.
	echo "error: Cache forced but no cache found." 1>&2
	exit 1
fi

# Make sure that the path we are given is one we can source
# (dash, we are looking at you).
if [ ! -z "${CACHEFILE}" ] && ! echo "${CACHEFILE}" | grep -q '^\.*/'; then
	CACHEFILE="./${CACHEFILE}"
fi

GENERATED_HEADER="Generated by autorevision - do not hand-hack!"

# Functions to extract data from different repo types.
# For git repos
# shellcheck disable=SC2039,SC2164,SC2155
gitRepo() {
	local oldPath="${PWD}"

	cd "$(git rev-parse --show-toplevel)"

	TYPE="git"

	BASENAME="$(basename "${PWD}")"

	UUID="$(git rev-list --max-parents=0 --date-order --reverse HEAD 2>/dev/null | sed -n 1p)"
	if [ -z "${UUID}" ]; then
		UUID="$(git rev-list --topo-order HEAD | tail -n 1)"
	fi

	# Is the working copy clean?
	test -z "$(git status --untracked-files=normal --porcelain)"
	WC_MODIFIED="${?}"

	# Enumeration of changesets
	NUM="$(git rev-list --count HEAD 2>/dev/null)"
	if [ -z "${NUM}" ]; then
		echo "warning: Counting the number of revisions may be slower due to an outdated git version less than 1.7.2.3. If something breaks, please update it." 1>&2
		NUM="$(git rev-list HEAD | wc -l)"
	fi

	# This may be a git-svn remote.  If so, report the Subversion revision.
	if [ -z "$(git config svn-remote.svn.url 2>/dev/null)" ]; then
		# The full revision hash
		FULL_HASH="$(git rev-parse HEAD)"

		# The short hash
		SHORT_HASH="$(echo "${FULL_HASH}" | cut -b 1-7)"
	else
		# The git-svn revision number
		FULL_HASH="$(git svn find-rev HEAD)"
		SHORT_HASH="${FULL_HASH}"
	fi

	# Current branch
	BRANCH="$(git rev-parse --symbolic-full-name --verify "$(git name-rev --name-only --no-undefined HEAD 2>/dev/null)" 2>/dev/null | sed -e 's:refs/heads/::' | sed -e 's:refs/::')"

	# Cache the description
	local DESCRIPTION="$(git describe --long --tags 2>/dev/null)"

	# Current or last tag ancestor (empty if no tags)
	TAG="$(echo "${DESCRIPTION}" | sed -e "s:-g${SHORT_HASH}\$::" -e 's:-[0-9]*$::')"

	# Distance to last tag or an alias of NUM if there is no tag
	if [ ! -z "${DESCRIPTION}" ]; then
		TICK="$(echo "${DESCRIPTION}" | sed -e "s:${TAG}-::" -e "s:-g${SHORT_HASH}::")"
	else
		TICK="${NUM}"
	fi

	# Date of the current commit
	DATE="$(TZ=UTC git show -s --date=iso-strict-local --pretty=format:%ad | sed -e 's|+00:00|Z|')"
	if [ -z "${DATE}" ]; then
		echo "warning: Action stamps require git version 2.7+." 1>&2
		DATE="$(git log -1 --pretty=format:%ci | sed -e 's: :T:' -e 's: ::' -e 's|+00:00|Z|')"
		local ASdis="1"
	fi

	# Action Stamp
	if [ -z "${ASdis}" ]; then
		ACTION_STAMP="${DATE}!$(git show -s --pretty=format:%cE)"
	else
		ACTION_STAMP=""
	fi

	cd "${oldPath}"
}

# For hg repos
# shellcheck disable=SC2039,SC2164
hgRepo() {
	local oldPath="${PWD}"

	cd "$(hg root)"

	TYPE="hg"

	BASENAME="$(basename "${PWD}")"

	UUID="$(hg log -r "0" -l 1 --template '{node}\n')"

	# Is the working copy clean?
	test -z "$(hg status -duram)"
	WC_MODIFIED="${?}"

	# Enumeration of changesets
	NUM="$(hg id -n | tr -d '+')"

	# The full revision hash
	FULL_HASH="$(hg log -r "${NUM}" -l 1 --template '{node}\n')"

	# The short hash
	SHORT_HASH="$(hg id -i | tr -d '+')"

	# Current bookmark (bookmarks are roughly equivalent to git's branches)
	# or branch if no bookmark
	BRANCH="$(hg id -B | cut -d ' ' -f 1)"
	# Fall back to the branch if there are no bookmarks
	if [ -z "${BRANCH}" ]; then
		BRANCH="$(hg id -b)"
	fi

	# Current or last tag ancestor (excluding auto tags, empty if no tags)
	TAG="$(hg log -r "${NUM}" -l 1 --template '{latesttag}\n' 2>/dev/null | sed -e 's:qtip::' -e 's:tip::' -e 's:qbase::' -e 's:qparent::' -e "s:$(hg --config 'extensions.color=' --config 'extensions.mq=' --color never qtop 2>/dev/null)::" | cut -d ' ' -f 1)"

	# Distance to last tag or an alias of NUM if there is no tag
	if [ ! -z "${TAG}" ]; then
		TICK="$(hg log -r "${NUM}" -l 1 --template '{latesttagdistance}\n' 2>/dev/null)"
	else
		TICK="${NUM}"
	fi

	# Date of the current commit
	DATE="$(hg log -r "${NUM}" -l 1 --template '{date|isodatesec}\n' 2>/dev/null | sed -e 's: :T:' -e 's: ::' -e 's|+00:00|Z|')"

	# Action Stamp
	ACTION_STAMP="$(TZ=UTC hg log -r "${NUM}" -l 1 --template '{date|localdate|rfc3339date}\n' 2>/dev/null | sed -e 's|+00:00|Z|')!$(hg log -r "${NUM}" -l 1 --template '{author|email}\n' 2>/dev/null)"

	cd "${oldPath}"
}

# For bzr repos
# shellcheck disable=SC2039,SC2164
bzrRepo() {
	local oldPath="${PWD}"

	cd "$(bzr root)"

	TYPE="bzr"

	BASENAME="$(basename "${PWD}")"

	# Currently unimplemented because more investigation is needed.
	UUID=""

	# Is the working copy clean?
	bzr version-info --custom --template='{clean}\n' | grep -q '1'
	WC_MODIFIED="${?}"

	# Enumeration of changesets
	NUM="$(bzr revno)"

	# The full revision hash
	FULL_HASH="$(bzr version-info --custom --template='{revision_id}\n')"

	# The short hash
	SHORT_HASH="${NUM}"

	# Nick of the current branch
	BRANCH="$(bzr nick)"

	# Current or last tag ancestor (excluding auto tags, empty if no tags)
	TAG="$(bzr tags --sort=time | sed '/?$/d' | tail -n1 | cut -d ' ' -f1)"

	# Distance to last tag or an alias of NUM if there is no tag
	if [ ! -z "${TAG}" ]; then
		TICK="$(bzr log --line -r "tag:${TAG}.." | tail -n +2 | wc -l | sed -e 's:^ *::')"
	else
		TICK="${NUM}"
	fi

	# Date of the current commit
	DATE="$(bzr version-info --custom --template='{date}\n' | sed -e 's: :T:' -e 's: ::')"

	# Action Stamp
	# Currently unimplemented because more investigation is needed.
	ACTION_STAMP=""

	cd "${oldPath}"
}

# For svn repos
# shellcheck disable=SC2039,SC2164,SC2155
svnRepo() {
	local oldPath="${PWD}"

	TYPE="svn"

	case "${PWD}" in
	/*trunk*|/*branches*|/*tags*)
		local fn="${PWD}"
		while [ "$(basename "${fn}")" != 'trunk' ] && [ "$(basename "${fn}")" != 'branches' ] && [ "$(basename "${fn}")" != 'tags' ] && [ "$(basename "${fn}")" != '/' ]; do
			local fn="$(dirname "${fn}")"
		done
		local fn="$(dirname "${fn}")"
		if [ "${fn}" = '/' ]; then
			BASENAME="$(basename "${PWD}")"
		else
			BASENAME="$(basename "${fn}")"
		fi
		;;
	*) BASENAME="$(basename "${PWD}")" ;;
	esac

	UUID="$(svn info --xml | sed -n -e 's:<uuid>::' -e 's:</uuid>::p')"

	# Cache svnversion output
	local SVNVERSION="$(svnversion)"

	# Is the working copy clean?
	echo "${SVNVERSION}" | grep -q "M"
	case "${?}" in
		0)
			WC_MODIFIED="1"
		;;
		1)
			if [ ! -z "${UNTRACKEDFILES}" ]; then
			# `svnversion` does not detect untracked files and `svn status` is really slow, so only run it if we really have to.
				if [ -z "$(svn status)" ]; then
					WC_MODIFIED="0"
				else
					WC_MODIFIED="1"
				fi
			else
				WC_MODIFIED="0"
			fi
		;;
	esac

	# Enumeration of changesets
	NUM="$(echo "${SVNVERSION}" | cut -d : -f 1 | sed -e 's:M::' -e 's:S::' -e 's:P::')"

	# The full revision hash
	FULL_HASH="${SVNVERSION}"

	# The short hash
	SHORT_HASH="${NUM}"

	# Current branch
	case "${PWD}" in
	/*trunk*|/*branches*|/*tags*)
		local lastbase=""
		local fn="${PWD}"
		while :
		do
			base="$(basename "${fn}")"
			if [ "${base}" = 'trunk' ]; then
				BRANCH='trunk'
				break
			elif [ "${base}" = 'branches' ] || [ "${base}" = 'tags' ]; then
				BRANCH="${lastbase}"
				break
			elif [ "${base}" = '/' ]; then
				BRANCH=""
				break
			fi
			local lastbase="${base}"
			local fn="$(dirname "${fn}")"
		done
		;;
	*) BRANCH="" ;;
	esac

	# Current or last tag ancestor (empty if no tags). But "current
	# tag" can't be extracted reliably because Subversion doesn't
	# have tags the way other VCSes do.
	TAG=""
	TICK=""

	# Date of the current commit
	DATE="$(svn info --xml | sed -n -e 's:<date>::' -e 's:</date>::p')"

	# Action Stamp
	ACTION_STAMP="${DATE}!$(svn log --xml -l 1 -r "${SHORT_HASH}" | sed -n -e 's:<author>::' -e 's:</author>::p')"

	cd "${oldPath}"
}


# Functions to output data in different formats.
# For bash output
shOutput() {
	cat > "${TARGETFILE}" << EOF
# ${GENERATED_HEADER}

TYPE="${TYPE}"
BASENAME="${BASENAME}"
UUID="${UUID}"
NUM="${NUM}"
DATE="${DATE}"
BRANCH="${BRANCH}"
TAG="${TAG}"
TICK="${TICK}"
VERSION="${VERSION}"

ACTION_STAMP="${ACTION_STAMP}"
FULL_HASH="${FULL_HASH}"
SHORT_HASH="${SHORT_HASH}"

WC_MODIFIED="${WC_MODIFIED}"

# end
EOF
}

# For source C output
cOutput() {
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */

const char *TYPE         = "${TYPE}";
const char *BASENAME     = "${BASENAME}";
const char *UUID         = "${UUID}";
const int NUM            = ${NUM};
const char *DATE         = "${DATE}";
const char *BRANCH       = "${BRANCH}";
const char *TAG          = "${TAG}";
const int TICK           = ${TICK};
const char *VERSION        = "${VERSION}";

const char *ACTION_STAMP = "${ACTION_STAMP}";
const char *FULL_HASH    = "${FULL_HASH}";
const char *SHORT_HASH   = "${SHORT_HASH}";

const int WC_MODIFIED     = ${WC_MODIFIED};

/* end */
EOF
}

# For header output
hOutput() {
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */
#ifndef AUTOREVISION_H
#define AUTOREVISION_H

#define TYPE		"${TYPE}"
#define BASENAME	"${BASENAME}"
#define UUID		"${UUID}"
#define NUM			${NUM}
#define DATE		"${DATE}"
#define BRANCH		"${BRANCH}"
#define TAG			"${TAG}"
#define TICK		${TICK}
#define VERSION		"${VERSION}"

#define ACTION_STAMP	"${ACTION_STAMP}"
#define FULL_HASH		"${FULL_HASH}"
#define SHORT_HASH		"${SHORT_HASH}"

#define WC_MODIFIED		${WC_MODIFIED}

#endif

/* end */
EOF
}

# A header output for use with xcode to populate info.plist strings
xcodeOutput() {
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */
#ifndef AUTOREVISION_H
#define AUTOREVISION_H

#define TYPE		${TYPE}
#define BASENAME	${BASENAME}
#define UUID		${UUID}
#define NUM			${NUM}
#define DATE		${DATE}
#define BRANCH		${BRANCH}
#define TAG			${TAG}
#define TICK		${TICK}
#define VERSION		${VERSION}

#define ACTION_STAMP	${ACTION_STAMP}
#define FULL_HASH		${FULL_HASH}
#define SHORT_HASH		${SHORT_HASH}

#define WC_MODIFIED		${WC_MODIFIED}

#endif

/* end */
EOF
}

# For Swift output
swiftOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	# For values that may not exist depending on the type of repo we
	# have read from, set them to `nil` when they are empty.
	if [ -z "${UUID}" ]; then
		UUID="nil"
	else
		UUID="\"${UUID}\""
	fi
	if [ -z "${TAG}" ]; then
		TAG="nil"
	else
		TAG="\"${TAG}\""
	fi
	: "${TICK:="nil"}"
	if [ -z "${VERSION}" ]; then
		VERSION="nil"
	else
		VERSION="\"${VERSION}\""
	fi
	if [ -z "${ACTION_STAMP}" ]; then
		ACTION_STAMP="nil"
	else
		ACTION_STAMP="\"${ACTION_STAMP}\""
	fi
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */

let TYPE			= "${TYPE}"
let BASENAME		= "${BASENAME}"
let UUID:	String?	= ${UUID}
let NUM:	Int		= ${NUM}
let DATE			= "${DATE}"
let BRANCH:	String	= "${BRANCH}"
let TAG:	String?	= ${TAG}
let TICK:	Int?	= ${TICK}
let VERSION:	String?	= ${VERSION}

let ACTION_STAMP:	String?	= ${ACTION_STAMP}
let FULL_HASH:		String	= "${FULL_HASH}"
let SHORT_HASH:		String	= "${SHORT_HASH}"

let WC_MODIFIED:	Bool	= ${WC_MODIFIED}

/* end */
EOF
}

# For Python output
pyOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="False" ;;
		1) WC_MODIFIED="True" ;;
	esac
	cat > "${TARGETFILE}" << EOF
# ${GENERATED_HEADER}

TYPE = "${TYPE}"
BASENAME = "${BASENAME}"
UUID = "${UUID}"
NUM = ${NUM}
DATE = "${DATE}"
BRANCH = "${BRANCH}"
TAG = "${TAG}"
TICK = ${TICK}
VERSION = "${VERSION}"

ACTION_STAMP = "${ACTION_STAMP}"
FULL_HASH = "${FULL_HASH}"
SHORT_HASH = "${SHORT_HASH}"

WC_MODIFIED = ${WC_MODIFIED}

# end
EOF
}

# For Perl output
plOutput() {
	cat << EOF
# ${GENERATED_HEADER}

\$TYPE = '${TYPE}';
\$BASENAME = '${BASENAME}';
\$UUID = '${UUID}';
\$NUM = ${NUM};
\$DATE = '${DATE}';
\$BRANCH = '${BRANCH}';
\$TAG = '${TAG}';
\$TICK = ${TICK};
\$VERSION = '${VERSION}';

\$ACTION_STAMP = '${ACTION_STAMP}';
\$FULL_HASH = '${FULL_HASH}';
\$SHORT_HASH = '${SHORT_HASH}';

\$WC_MODIFIED = ${WC_MODIFIED};

# end
1;
EOF
}

# For lua output
luaOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	cat > "${TARGETFILE}" << EOF
-- ${GENERATED_HEADER}

TYPE = "${TYPE}"
BASENAME = "${BASENAME}"
UUID = "${UUID}"
NUM = ${NUM}
DATE = "${DATE}"
BRANCH = "${BRANCH}"
TAG = "${TAG}"
TICK = ${TICK}
VERSION = "${VERSION}"

ACTION_STAMP = "${ACTION_STAMP}"
FULL_HASH = "${FULL_HASH}"
SHORT_HASH = "${SHORT_HASH}"

WC_MODIFIED = ${WC_MODIFIED}

-- end
EOF
}

# For php output
phpOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	cat > "${TARGETFILE}" << EOF
<?php
# ${GENERATED_HEADER}

return array(
	"TYPE" => "${TYPE}",
	"BASENAME" => "${BASENAME}",
	"UUID" => "${UUID}",
	"NUM" => ${NUM},
	"DATE" => "${DATE}",
	"BRANCH" => "${BRANCH}",
	"TAG" => "${TAG}",
	"TICK" => ${TICK},
	"VERSION" => "${VERSION}",
	"ACTION_STAMP" => "${ACTION_STAMP}",
	"FULL_HASH" => "${FULL_HASH}",
	"SHORT_HASH" => "${SHORT_HASH}",
	"WC_MODIFIED" => ${WC_MODIFIED}
);

# end
?>
EOF
}

# For ini output
iniOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	cat > "${TARGETFILE}" << EOF
; ${GENERATED_HEADER}
[VCS]
TYPE = "${TYPE}"
BASENAME = "${BASENAME}"
UUID = "${UUID}"
NUM = ${NUM}
DATE = "${DATE}"
BRANCH = "${BRANCH}"
TAG = "${TAG}"
TICK = ${TICK}
VERSION = "${VERSION}"
ACTION_STAMP = "${ACTION_STAMP}"
FULL_HASH = "${FULL_HASH}"
SHORT_HASH = "${SHORT_HASH}"
WC_MODIFIED = ${WC_MODIFIED}
; end
EOF
}

# For javascript output
jsOutput() {
	case "${WC_MODIFIED}" in
		1) WC_MODIFIED="true" ;;
		0) WC_MODIFIED="false" ;;
	esac
	cat > "${TARGETFILE}" << EOF
/** ${GENERATED_HEADER} */

var autorevision = {
	TYPE: "${TYPE}",
	BASENAME: "${BASENAME}",
	UUID: "${UUID}",
	NUM: ${NUM},
	DATE: "${DATE}",
	BRANCH: "${BRANCH}",
	TAG: "${TAG}",
	TICK: ${TICK},
	VERSION: "${VERSION}",

	ACTION_STAMP: "${ACTION_STAMP}",
	FULL_HASH: "${FULL_HASH}",
	SHORT_HASH: "${SHORT_HASH}",

	WC_MODIFIED: ${WC_MODIFIED}
};

/** Node.js compatibility */
if (typeof module !== 'undefined') {
	module.exports = autorevision;
}

/** end */
EOF
}

# For JSON output
jsonOutput() {
	case "${WC_MODIFIED}" in
		1) WC_MODIFIED="true" ;;
		0) WC_MODIFIED="false" ;;
	esac
	cat > "${TARGETFILE}" << EOF
{
	"_comment": "${GENERATED_HEADER}",
	"TYPE": "${TYPE}",
	"BASENAME": "${BASENAME}",
	"UUID": "${UUID}",
	"NUM": ${NUM},
	"DATE": "${DATE}",
	"BRANCH":"${BRANCH}",
	"TAG": "${TAG}",
	"TICK": ${TICK},
	"VERSION": "${VERSION}",

	"ACTION_STAMP": "${ACTION_STAMP}",
	"FULL_HASH": "${FULL_HASH}",
	"SHORT_HASH": "${SHORT_HASH}",

	"WC_MODIFIED": ${WC_MODIFIED}
}
EOF
}

# For Java output
javaOutput() {
	case "${WC_MODIFIED}" in
		1) WC_MODIFIED="true" ;;
		0) WC_MODIFIED="false" ;;
	esac
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */

public class autorevision {
    public static final String TYPE = "${TYPE}";
    public static final String BASENAME = "${BASENAME}";
    public static final String UUID = "${UUID}";
    public static final long NUM = ${NUM};
    public static final String DATE = "${DATE}";
    public static final String BRANCH = "${BRANCH}";
    public static final String TAG = "${TAG}";
    public static final long TICK = ${TICK};
    public static final String VERSION = "${VERSION}";

    public static final String ACTION_STAMP = "${ACTION_STAMP}";
    public static final String FULL_HASH = "${FULL_HASH}";
    public static final String SHORT_HASH = "${SHORT_HASH}";

    public static final boolean WC_MODIFIED = ${WC_MODIFIED};
}
EOF
}

# For Java properties output
javapropOutput() {
	case "${WC_MODIFIED}" in
		1) WC_MODIFIED="true" ;;
		0) WC_MODIFIED="false" ;;
	esac
	cat > "${TARGETFILE}" << EOF
# ${GENERATED_HEADER}

TYPE=${TYPE}
BASENAME=${BASENAME}
UUID=${UUID}
NUM=${NUM}
DATE=${DATE}
BRANCH=${BRANCH}
TAG=${TAG}
TICK=${TICK}
VERSION=${VERSION}

ACTION_STAMP=${ACTION_STAMP}
FULL_HASH=${FULL_HASH}
SHORT_HASH=${SHORT_HASH}

WC_MODIFIED=${WC_MODIFIED}
EOF
}

# For m4 output
m4Output() {
	cat > "${TARGETFILE}" << EOF
dnl ${GENERATED_HEADER}
define(\`TYPE', \`${TYPE}')dnl
define(\`BASENAME', \`${BASENAME}')dnl
define(\`UUID', \`${UUID}')dnl
define(\`NUM', \`${NUM}')dnl
define(\`DATE', \`${DATE}')dnl
define(\`BRANCH', \`${BRANCH}')dnl
define(\`TAG', \`${TAG}')dnl
define(\`TICK', \`${TICK}')dnl
define(\`VERSION', \`${VERSION}')dnl
define(\`ACTIONSTAMP', \`${ACTION_STAMP}')dnl
define(\`FULLHASH', \`${FULL_HASH}')dnl
define(\`SHORTHASH', \`${SHORT_HASH}')dnl
define(\`WC_MODIFIED', \`${WC_MODIFIED}')dnl
EOF
}

# For (La)TeX output
texOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	cat > "${TARGETFILE}" << EOF
% ${GENERATED_HEADER}
\def \vcsType {${TYPE}}
\def \vcsBasename {${BASENAME}}
\def \vcsUUID {${UUID}}
\def \vcsNum {${NUM}}
\def \vcsDate {${DATE}}
\def \vcsBranch {${BRANCH}}
\def \vcsTag {${TAG}}
\def \vcsTick {${TICK}}
\def \vcsExtra {${VERSION}}
\def \vcsACTIONSTAMP {${ACTION_STAMP}}
\def \vcsFullHash {${FULL_HASH}}
\def \vcsShortHash {${SHORT_HASH}}
\def \vcsWCModified {${WC_MODIFIED}}
\endinput
EOF
}

# For scheme output
schemeOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="#f" ;;
		1) WC_MODIFIED="#t" ;;
	esac
	cat > "${TARGETFILE}" << EOF
;; ${GENERATED_HEADER}
(define TYPE        "${TYPE}")
(define BASENAME    "${BASENAME}")
(define UUID        "${UUID}")
(define NUM         ${NUM})
(define DATE        "${DATE}")
(define BRANCH      "${BRANCH}")
(define TAG         "${TAG}")
(define TICK        ${TICK})
(define VERSION       "${VERSION}")

(define ACTION_STAMP   "${ACTION_STAMP}")
(define FULL_HASH   "${FULL_HASH}")
(define SHORT_HASH  "${SHORT_HASH}")

(define WC_MODIFIED ${WC_MODIFIED})
;; end
EOF
}

# For clojure output
clojureOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="false" ;;
		1) WC_MODIFIED="true" ;;
	esac
	cat > "${TARGETFILE}" << EOF
;; ${GENERATED_HEADER}
(def TYPE        "${TYPE}")
(def BASENAME    "${BASENAME}")
(def UUID        "${UUID}")
(def NUM         ${NUM})
(def DATE        "${DATE}")
(def BRANCH      "${BRANCH}")
(def TAG         "${TAG}")
(def TICK        ${TICK})
(def VERSION       "${VERSION}")

(def ACTION_STAMP   "${ACTION_STAMP}")
(def FULL_HASH      "${FULL_HASH}")
(def SHORT_HASH     "${SHORT_HASH}")

(def WC_MODIFIED ${WC_MODIFIED})
;; end
EOF
}

# For rpm spec file output
rpmOutput() {
	cat > "${TARGETFILE}" << EOF
# ${GENERATED_HEADER}
$([ "${TYPE}" ] && echo "%define vcs_type		${TYPE}")
$([ "${BASENAME}" ] && echo "%define vcs_basename		${BASENAME}")
$([ "${UUID}" ] && echo "%define vcs_uuid		${UUID}")
$([ "${NUM}" ] && echo "%define vcs_num			${NUM}")
$([ "${DATE}" ] && echo "%define vcs_date		${DATE}")
$([ "${BRANCH}" ] && echo "%define vcs_branch		${BRANCH}")
$([ "${TAG}" ] && echo "%define vcs_tag			${TAG}")
$([ "${TICK}" ] && echo "%define vcs_tick		${TICK}")
$([ "${VERSION}" ] && echo "%define vcs_extra		${VERSION}")

$([ "${ACTION_STAMP}" ] && echo "%define vcs_action_stamp		${ACTION_STAMP}")
$([ "${FULL_HASH}" ] && echo "%define vcs_full_hash		${FULL_HASH}")
$([ "${SHORT_HASH}" ] && echo "%define vcs_short_hash		${SHORT_HASH}")

$([ "${WC_MODIFIED}" ] && echo "%define vcs_wc_modified		${WC_MODIFIED}")
# end
EOF
}

# shellcheck disable=SC2155,SC2039
hppOutput() {
	local NAMESPACE="$(echo "${BASENAME}" | sed -e 's:_::g' | tr '[:lower:]' '[:upper:]')"
	cat > "${TARGETFILE}" << EOF
/* ${GENERATED_HEADER} */

#ifndef ${NAMESPACE}_AUTOREVISION_H
#define ${NAMESPACE}_AUTOREVISION_H

#include <string>

namespace $(echo "${NAMESPACE}" | tr '[:upper:]' '[:lower:]')
{
	const std::string TYPE		= "${TYPE}";
	const std::string BASENAME	= "${BASENAME}";
	const std::string UUID		= "${UUID}";
	const int NUM				= ${NUM};
	const std::string DATE		= "${DATE}";
	const std::string BRANCH	= "${BRANCH}";
	const std::string TAG		= "${TAG}";
	const int TICK				= ${TICK};
	const std::string VERSION		= "${VERSION}";

	const std::string ACTION_STAMP	= "${ACTION_STAMP}";
	const std::string FULL_HASH		= "${FULL_HASH}";
	const std::string SHORT_HASH	= "${SHORT_HASH}";

	const int WC_MODIFIED			= ${WC_MODIFIED};
}

#endif

/* end */
EOF
}

matlabOutput() {
	case "${WC_MODIFIED}" in
		0) WC_MODIFIED="FALSE" ;;
		1) WC_MODIFIED="TRUE" ;;
	esac
	cat > "${TARGETFILE}" << EOF
% ${GENERATED_HEADER}

TYPE = '${TYPE}';
BASENAME = '${BASENAME}';
UUID = '${UUID}';
NUM = ${NUM};
DATE = '${DATE}';
BRANCH = '${BRANCH}';
TAG = '${TAG}';
TICK = ${TICK};
VERSION = '${VERSION}';

ACTION_STAMP = '${ACTION_STAMP}';
FULL_HASH = '${FULL_HASH}';
SHORT_HASH = '${SHORT_HASH}';

WC_MODIFIED = ${WC_MODIFIED};

% end
EOF
}

octaveOutput() {
	cat > "${TARGETFILE}" << EOF
% ${GENERATED_HEADER}

TYPE = '${TYPE}';
BASENAME = '${BASENAME}';
UUID = '${UUID}';
NUM = ${NUM};
DATE = '${DATE}';
BRANCH = '${BRANCH}';
TAG = '${TAG}';
TICK = ${TICK};
VERSION = '${VERSION}';

ACTION_STAMP = '${ACTION_STAMP}';
FULL_HASH = '${FULL_HASH}';
SHORT_HASH = '${SHORT_HASH}';

WC_MODIFIED = ${WC_MODIFIED};

% end
EOF
}


# Helper functions
# Count path segments
# shellcheck disable=SC2039
pathSegment() {
	local pathz="${1}"
	local depth="0"

	if [ ! -z "${pathz}" ]; then
		# Continue until we are at / or there are no path separators left.
		while [ ! "${pathz}" = "/" ] && [ ! "${pathz}" = "$(echo "${pathz}" | sed -e 's:/::')" ]; do
			pathz="$(dirname "${pathz}")"
			depth="$((depth+1))"
		done
	fi
	echo "${depth}"
}

# Largest of four numbers
# shellcheck disable=SC2039
multiCompare() {
	local larger="${1}"
	local numA="${2}"
	local numB="${3}"
	local numC="${4}"

	[ "${numA}" -gt "${larger}" ] && larger="${numA}"
	[ "${numB}" -gt "${larger}" ] && larger="${numB}"
	[ "${numC}" -gt "${larger}" ] && larger="${numC}"
	echo "${larger}"
}

# Test for repositories
# shellcheck disable=SC2155,SC2039
repoTest() {
	REPONUM="0"
	if [ ! -z "$(git rev-parse HEAD 2>/dev/null)" ]; then
		local gitPath="$(git rev-parse --show-toplevel)"
		local gitDepth="$(pathSegment "${gitPath}")"
		REPONUM="$((REPONUM+1))"
	else
		local gitDepth="0"
	fi
	if [ ! -z "$(hg root 2>/dev/null)" ]; then
		local hgPath="$(hg root 2>/dev/null)"
		local hgDepth="$(pathSegment "${hgPath}")"
		REPONUM="$((REPONUM+1))"
	else
		local hgDepth="0"
	fi
	if [ ! -z "$(bzr root 2>/dev/null)" ]; then
		local bzrPath="$(bzr root 2>/dev/null)"
		local bzrDepth="$(pathSegment "${bzrPath}")"
		REPONUM="$((REPONUM+1))"
	else
		local bzrDepth="0"
	fi
	if [ ! -z "$(svn info 2>/dev/null)" ]; then
		local stringz="<wcroot-abspath>"
		local stringx="</wcroot-abspath>"
		local svnPath="$(svn info --xml | sed -n -e "s:${stringz}::" -e "s:${stringx}::p")"
		# An old enough svn will not be able give us a path; default
		# to 1 for that case.
		if [ -z  "${svnPath}" ]; then
			local svnDepth="1"
		else
			local svnDepth="$(pathSegment "${svnPath}")"
		fi
		REPONUM="$((REPONUM+1))"
	else
		local svnDepth="0"
	fi

	# Do not do more work then we have to.
	if [ "${REPONUM}" = "0" ]; then
		return
	fi

	# Figure out which repo is the deepest and use it.
	local wonRepo="$(multiCompare "${gitDepth}" "${hgDepth}" "${bzrDepth}" "${svnDepth}")"
	if [ "${wonRepo}" = "${gitDepth}" ]; then
		gitRepo
	elif [ "${wonRepo}" = "${hgDepth}" ]; then
		hgRepo
	elif [ "${wonRepo}" = "${bzrDepth}" ]; then
		bzrRepo
	elif [ "${wonRepo}" = "${svnDepth}" ]; then
		svnRepo
	fi
}



# Detect which repos we are in and gather data.
# shellcheck source=/dev/null
if [ -f "${CACHEFILE}" ] && [ "${CACHEFORCE}" = "1" ]; then
	# When requested only read from the cache to populate our symbols.
	. "${CACHEFILE}"
else
	# If a value is not set through the environment set VERSION to nothing.
	: "${VERSION:=""}"
	repoTest

	if [ -f "${CACHEFILE}" ] && [ "${REPONUM}" = "0" ]; then
		# We are not in a repo; try to use a previously generated cache to populate our symbols.
		. "${CACHEFILE}"
		# Do not overwrite the cache if we know we are not going to write anything new.
		CACHEFORCE="1"
	elif [ "${REPONUM}" = "0" ]; then
		echo "error: No repo or cache detected." 1>&2
		exit 1
	fi
fi


# -s output is handled here.
if [ ! -z "${VAROUT}" ]; then
	if [ "${VAROUT}" = "TYPE" ]; then
		echo "${TYPE}"
	elif [ "${VAROUT}" = "BASENAME" ]; then
		echo "${BASENAME}"
	elif [ "${VAROUT}" = "NUM" ]; then
		echo "${NUM}"
	elif [ "${VAROUT}" = "DATE" ]; then
		echo "${DATE}"
	elif [ "${VAROUT}" = "BRANCH" ]; then
		echo "${BRANCH}"
	elif [ "${VAROUT}" = "TAG" ]; then
		echo "${TAG}"
	elif [ "${VAROUT}" = "TICK" ]; then
		echo "${TICK}"
	elif [ "${VAROUT}" = "FULL_HASH" ]; then
		echo "${FULL_HASH}"
	elif [ "${VAROUT}" = "SHORT_HASH" ]; then
		echo "${SHORT_HASH}"
	elif [ "${VAROUT}" = "WC_MODIFIED" ]; then
		echo "${WC_MODIFIED}"
	elif [ "${VAROUT}" = "ACTION_STAMP" ]; then
		echo "${ACTION_STAMP}"
	else
		echo "error: Not a valid output symbol." 1>&2
		exit 1
	fi
fi


# Detect requested output type and use it.
if [ ! -z "${AFILETYPE}" ]; then
	if [ "${AFILETYPE}" = "c" ]; then
		cOutput
	elif [ "${AFILETYPE}" = "h" ]; then
		hOutput
	elif [ "${AFILETYPE}" = "xcode" ]; then
		xcodeOutput
	elif [ "${AFILETYPE}" = "swift" ]; then
		swiftOutput
	elif [ "${AFILETYPE}" = "sh" ]; then
		shOutput
	elif [ "${AFILETYPE}" = "py" ] || [ "${AFILETYPE}" = "python" ]; then
		pyOutput
	elif [ "${AFILETYPE}" = "pl" ] || [ "${AFILETYPE}" = "perl" ]; then
		plOutput
	elif [ "${AFILETYPE}" = "lua" ]; then
		luaOutput
	elif [ "${AFILETYPE}" = "php" ]; then
		phpOutput
	elif [ "${AFILETYPE}" = "ini" ]; then
		iniOutput
	elif [ "${AFILETYPE}" = "js" ]; then
		jsOutput
	elif [ "${AFILETYPE}" = "json" ]; then
		jsonOutput
	elif [ "${AFILETYPE}" = "java" ]; then
		javaOutput
	elif [ "${AFILETYPE}" = "javaprop" ]; then
		javapropOutput
	elif [ "${AFILETYPE}" = "tex" ]; then
		texOutput
	elif [ "${AFILETYPE}" = "m4" ]; then
		m4Output
	elif [ "${AFILETYPE}" = "scheme" ]; then
		schemeOutput
	elif [ "${AFILETYPE}" = "clojure" ]; then
		clojureOutput
	elif [ "${AFILETYPE}" = "rpm" ]; then
		rpmOutput
	elif [ "${AFILETYPE}" = "hpp" ]; then
		hppOutput
	elif [ "${AFILETYPE}" = "matlab" ]; then
		matlabOutput
	elif [ "${AFILETYPE}" = "octave" ]; then
		octaveOutput
	else
		echo "error: Not a valid output type." 1>&2
		exit 1
	fi
fi


# If requested, make a cache file.
if [ ! -z "${CACHEFILE}" ] && [ ! "${CACHEFORCE}" = "1" ]; then
	TARGETFILE="${CACHEFILE}.tmp"
	shOutput

	# Check to see if there have been any actual changes.
	if [ ! -f "${CACHEFILE}" ]; then
		mv -f "${CACHEFILE}.tmp" "${CACHEFILE}"
	elif cmp -s "${CACHEFILE}.tmp" "${CACHEFILE}"; then
		rm -f "${CACHEFILE}.tmp"
	else
		mv -f "${CACHEFILE}.tmp" "${CACHEFILE}"
	fi
fi
