#!/usr/bin/env python
# SPDX-License-Identifier: BSD-2-clause
'''\
Keystroke commands:

'a': Change peer display to apeers mode, showing association IDs.
'd': Toggle select mode (some peer will be reverse-video highlighted when on)
'j': Select next peer (in select mode)
'k': Select previous peer (in select mode)
'n': Toggle display of hostnames (vs. IP addresses).
'o': Change peer display to opeers mode, showing destination address.
'p': Change peer display to default mode, showing refid
'q': Cleanly terminate the program.
's': Show all hosts, not just reachable ones.
'w': Toggle wide mode.
'x': Cleanly terminate the program.
' ': Rotate through display modes. 
'?': Display helpscreen
'''

from __future__ import print_function, division

import sys, time, getopt

try:
    import ntp.packet
    import ntp.util
    import ntp.ntpc
    import ntp.version
    import ntp.control
    import ntp.magic
except ImportError as e:
    sys.stderr.write("ntpmon: can't find Python NTP library -- check PYTHONPATH.\n")
    sys.stderr.write("%s\n" % e)
    sys.exit(1)

try:
    import curses
except ImportError as e:
    sys.stderr.write("ntpmon: can't find Python curses library -- check PYTHONPATH.\n")
    sys.stderr.write("%s\n" % e)
    sys.exit(1)

stdscr = None

def iso8601(t):
    "ISO8601 string from Unix time, including fractional second."
    return time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(time.time()))

def statline(_peerlist, _mrulist, nyquist):
    "Generate a status line"
    # We don't use stdversion here because the presence of a date is confusing
    leader = sysvars['version']
    if span.entries:
        trailer = "Last update: %s (%s)" \
                  % (iso8601(span.entries[0].last), ntp.util.PeerSummary.prettyinterval(nyquist))
    else:
        trailer = ""
    spacer = (peer_report.termwidth - len(leader) - len(trailer)) * " "
    return leader + spacer + trailer

class Fatal(Exception):
    "Unrecoverable error."
    def __init__(self, msg):
        Exception.__init__(self)
        self.msg = msg
    def __str__(self):
        return self.msg

class OutputContext:
    def __enter__(self):
        "Begin critical region."
        global stdscr
        stdscr = curses.initscr()
        curses.curs_set(0)
        curses.cbreak()
        curses.noecho()
        stdscr.keypad(1)
    def __exit__(self, extype_unused, value_unused, traceback_unused):
        curses.endwin()

usage = '''
USAGE: ntpmon [-V] [host]
'''

if __name__ == '__main__':
    try:
        (options, arguments) = getopt.getopt(sys.argv[1:],
                                             "V", ["version"])
    except getopt.GetoptError as e:
        sys.stderr.write("%s\n" % e)
        sys.stderr.write(usage)
        raise SystemExit(1)
    progname = sys.argv[0]

    showhostnames = True
    wideremote = False
    showall = False

    for (switch, val) in options:
        if switch in ("-V", "--version"):
            print("ntpmon %s" % ntp.util.stdversion())
            raise SystemExit(0)

    poll_interval = 1
    helpmode = selectmode = detailmode = False
    selected = -1
    peer_report = ntp.util.PeerSummary(displaymode="peers",
                                       pktversion=ntp.magic.NTP_VERSION,
                                       showhostnames=showhostnames,
                                       wideremote=wideremote,
                                       termwidth=80,
                                       debug=0)
    mru_report = ntp.util.MRUSummary(showhostnames)
    try:
        session = ntp.packet.ControlSession()
        if 0: # debugging hacks, UI is $EDITOR
          session.logfp = open("ntpmon.log", "a", 1) # 1 => line buffered
          session.debug = 4
          peer_report.logfp = session.logfp
          peer_report.debug = session.debug
          mru_report.logfp = session.logfp
          mru_report.debug = session.debug
        session.openhost(arguments[0] if arguments else "localhost")
        sysvars = session.readvar()
        with OutputContext() as ctx:
            while True:
                stdscr.clear()
                stdscr.addstr(0, 0, "")
                if helpmode:
                    stdscr.addstr(__doc__)
                    stdscr.addstr("\nPress any key to resume monitoring")
                    stdscr.refresh()
                    stdscr.timeout(-1)
                else:
                    try:
                        peers = session.readstat()
                    except ntp.packet.ControlException as e:
                        raise Fatal(e.message)
                    except IOError as e:
                        raise Fatal(e.strerror)
                    stdscr.addstr(peer_report.header() + "\n", curses.A_BOLD)
                    if len(peers) == 0:
                        raise Fatal("no peers reported")
                    try:
                        hpolls = []
                        for (i, peer) in enumerate(peers):
                            if not showall and \
                                    not (ntp.control.CTL_PEER_STATVAL(peer.status)
                                      & (ntp.control.CTL_PST_CONFIG|ntp.control.CTL_PST_REACH)):
                                continue
                            try:
                                variables = session.readvar(peer.associd)
                                hpolls.append(variables['hpoll'])
                            except ntp.packet.ControlException as e:
                                raise Fatal(e.message + "\n")
                            except IOError as e:
                                raise Fatal(e.strerror)
                            except IndexError:
                                raise Fatal("no 'hpoll' variable in peer response")
                            if not variables:
                                continue
                            if selectmode and selected == i:
                                hilite = curses.A_REVERSE
                            else:
                                hilite = curses.A_NORMAL
                            stdscr.addstr(peer_report.summary(session.rstatus,
                                                    variables, peer.associd),
                                          hilite)

                        # Now the MRU report
                        limit = stdscr.getmaxyx()[0] - len(peers)
                        span = session.mrulist(recent=limit)
                        mru_report.now = time.time()

                        # Nyquist-interval sampling - half the
                        # smallest poll interval seen in the last
                        # cycle, rounded up to 1 second.                        
                        nyquist = int(min(peer_report.intervals()) / 2)
                        nyquist = 1 if nyquist == 0 else nyquist
                        # The status line
                        sl = statline(peer_report, mru_report, nyquist)
                        stdscr.addstr(sl + "\n", curses.A_REVERSE|curses.A_DIM)
                        if detailmode:
                            vars = session.readvar(peers[i].associd,
                                                   [],
                                                   ntp.control.CTL_OP_READVAR)
                            stdscr.addstr(str(vars))
                        elif span.entries:
                            stdscr.addstr(ntp.util.MRUSummary.header + "\n",
                                          curses.A_BOLD)
                            for entry in reversed(span.entries):
                                stdscr.addstr(mru_report.summary(entry) + "\n")
                    except curses.error:
                        # An addstr overran the screen, no worries
                        pass
                    # Display all
                    stdscr.refresh()
                    stdscr.timeout(nyquist * 1000)
                try:
                    helpmode = False
                    key = stdscr.getkey()
                    if key == 'q' or key == 'x':
                        raise SystemExit(0)
                    elif key == 'a':
                        peer_report.displaymode = 'apeers'
                    elif key == 'd':
                        if not selectmode:
                            selected = 0
                        selectmode = not selectmode
                    elif key == '?':
                        helpmode = True
                    elif key == 'n':
                        peer_report.showhostnames = not peer_report.showhostnames
                        mru_report.showhostnames = not mru_report.showhostnames
                    elif key == 'o':
                        peer_report.displaymode = 'opeers'
                    elif key == 'p':
                        peer_report.displaymode = 'peers'
                    elif key == 's':
                        showall = not showall
                    elif key == 'w':
                        peer_report.wideremote = not peer_report.wideremote
                    elif key == " ":
                        if selectmode:
                            detailmode = not detailmode
                        else:
                            if peer_report.displaymode == 'peers':
                                peer_report.displaymode = 'apeers'
                            elif peer_report.displaymode == 'apeers':
                                peer_report.displaymode = 'opeers'
                            else:
                                peer_report.displaymode = 'peers'
                    elif key == 'j' or key == curses.KEY_DOWN:
                        selected += 1
                        selected %= len(peers)
                    elif key == 'k' or key == curses.KEY_UP:
                        selected += len(peers) - 1
                        selected %= len(peers)
                    elif key == '?':
                        helpmode = True
                except curses.error:
                    pass
    except KeyboardInterrupt:
        print("")
    except (Fatal, ntp.packet.ControlException) as e:
        print(e)
    except IOError:
        print("Bailing out...")

# end
