from waflib import Utils


def build(ctx):
	srcnode = ctx.srcnode.abspath()
	bldnode = ctx.bldnode.abspath()


	s = ctx(
		features	= "subst",
		source		= "nl.pl.in",
		target		= "nl.pl",
		chmod		= Utils.O755
	)

	s.__dict__.update({"PATH_PERL": ctx.env.BIN_PERL})

	ctx.add_group()	# Make sure nl.pl is created first

	# XXX: nl.pl should be written to write out the target.  Redirection confuses the build system
	#      as any error would result in the target existing (0-byte file).  Writing it from the
	#      source will ensure the target doesn't exist unless it's successful.
	ctx(
		rule		= "${CC} -E -I%s -I%s/include -I%s/lib/isc/include -I%s/lib/isc/unix/include ${SRC} | ${BIN_PERL} %s/ntpdc/nl.pl > ${TGT}" % (bldnode, srcnode, srcnode, srcnode, bldnode),
		features	= "c bld_include src_include",
		source		= "nl_in.c",
		target		= "nl.c"
	)

	ctx.add_group()	# Make sure nl.c is created next


	ntpdc_layout_source = [
		"ntpdc-layout.c",
	]

	ctx(
		target		= "ntpdc-layout",
		features	= "c cprogram bld_include src_include libisc_include",
		source		= ntpdc_layout_source,
		includes	= [
						"%s/ntpdc/" % bldnode
					],
	)

	ctx.add_group()	# Make sure ntpdc-layout is created next


	ntpdc_source = [
		"nl_in.c",
		"ntpdc-opts.c",
		"ntpdc.c",
		"ntpdc_ops.c"
	]

	ctx(
		target		= "ntpdc",
		features	= "c cprogram bld_include src_include libisc_include libopts_include ntp_version",
		source		= ntpdc_source,
		includes	= [
						"%s/ntpdc/" % bldnode
					],
		defines		= ["HAVE_CONFIG_H=1"],
		use			= "ntp opts isc M RT PTHREAD",
	)

