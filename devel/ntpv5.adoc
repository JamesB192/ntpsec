= Design notes for the NTPv5 protocol

== Why NTPv5? ==

Why an NTPv5?  Why not muddle through with NTPv4?  The principal
reason to avoid rollover cases in its time representation.  There is an
epoch turnover in 2036; it would be wise to have moved to full 64-bit
date stamps well before we have to deal with uncharted parts of the
software's behavior space.

NTPv4 is showing its age in other ways as well.  Its mechanism for
avoiding source loops does not play well with IPv6, and collisions
have vbeen observed in the wild.

There are various other functional capabilities that would be very
useful if they could be standardized but currently are not.  Since
we need to deal with the 32-bit-counter issues anyway, the time
is right to design a protocol which (a) includes what we now know
is needed, and (b) is extensible for future use.

== Packet metaprotocol

Every packet is led with a character '+'. This is chosen so that when
a packet analyzer for NTPv4 looks at the first byte, it sees 0x02B,
which unpacks to LI:00 VN:5 MODE:3.  The version 5, which is out of
band for an NTPv4 packet, will cause the packet to be rejected by
conforming NTPv4 implementations that do not handle v5.

The Mills reference version of NTP and all codebases descended from
it (including NTPSec) *do* recognize Version 5 as out of band
and will not pass such packets to a Version 4 protocol machine.

The remainder of the packet is encoded in a strict subset of JSON
intended to avoid known edge cases decribed in <<<Seriot2016>>>.  The
outermost enclosing {} is required. Trailing commas on elements are
disallowed. UTF-8 may occur but only within string literals, all else
must be 7-bit ASCII. Scientific notation is not used.

Transmitted packet sizes MUST be limited to 65,506 octets, so that the
largest possible NTPv5 packet and a trailing NUL will fit in one UDP
datagram.  To prevent DoS attacks, implementations MAY limit the
packet size they will receive to a lower value; however implementations
MUST accept packets of at least 512 octets.

Packets SHOULD use only ASCII space (0x20) as a JSON whitespace
character. Packets MAY ship with no whitespace.

In the remainder of this document, packet fields will be described as
keyword-value pairs. The keyword *is* explicit in the JSON, and the
mapping to on-the-wire representation is as implied in <<<RFC8259>>>.

Once the semantics of a packet field has been defined, it MAY be
omitted but MUST NOT change incompatibly. Protocol extensions MUST be
done with new fields.

Implementations MAY ignore fields they do not recognize, but SHOULD
make some effort to generate error notifications when this occurs.
Policy for rate-limiting such notifications is implementor's choice.

The Appendix discusses some paths not taken and the reasons they weren't.

== Packet types ==

We define five packet types:

[options="header"]
|===========================================================
| Type name        | NTPv4 equivalent | Description
| time poll        | mode 2 or 3      | request for time update
| time response    | mode 4           | time update
| control request  | mode 6           | request for server information
| control response | mode 6           | response with server information
| error            | KOD              | error notification
|===========================================================

Conforming implementations MUST respond to unknown packet types with
an error response.

== Time format and scale ==

A timestamp field is an MJD (Modified Julian Date) literal in the form
"YYYY/DDD/SSSS.SSSS"; Calendar year, day within year, seconds and
fractional seconds from midnight.  Fields are not length limited, thus
the year may have more than four digits and the subsecond precision of
the timestamp is not limited by this format.

Conforming implementations MUST report in TAI/UTC seconds and servers
MUST NOT transmmit leap-smeared or otherwise "adjusted" time; client
implementations are expected to perform leap smearing locally if at
all.

== Time request packet

A time request packet MUST specify mode 3. No other content is required

Note: this corresponds to a minimal SNTP packet under RFC2030.

== Time response packet

A time response packet MUST specify mode 4.

The following fields are retyained from NTPv4:

"l":: Leap Indicator. Decimal numeric. Interpreted as in RFC5905.
      Optional, defaulting to 0 = no warning. Conforming
      implementations MUST report warning or unsynchronized
      status when appropriate.

"m":: Mode: Decimal numeric. Interpreted as in RFC5905.

"s":: Stratum. Decimal numeric. Interpreted as in RFC5905.

"i":: Poll. Decimal numeric. Interpreted as in RFC5905.

"p":: Precision.   Decimal numeric. Interpreted as in RFC5905.

"de":: Root delay. Decimal numeric (seconds and fractional seconds).
       Interpreted as in RFC5905.

"di":: Root dispersion. Decimal numeric (seconds and fractional seconds).
       Interpreted as in RFC5905.

"rt":: Receive Timestamp. String, interpreted as timestamp format.

"tt":: Transmit Timestamp. String, interpreted as timestamp format.

NTPv4 fields explicitly omitted from NTPv5 are version, reference ID,
origin timestamp, and reference timestamp.

//FIXME: How do we do the NTPv4 refid's anti-looping job?
//FIXME:: Daniel get to make the case why poll and stratum are useless.

Additional NTPv5 fields:

"id":: Request ID to be echoed in the response. Decimal numeric. Optional.

"leap":: Current leap-second offset from UTC. Decimal numeric. Optional.

"nts":: NTS authentication cookie. String, interpreted as hex digit pairs.

== Control requests and responses.

Control request and responses MUST specify mode 6.  A request is
distinguished by the presence of a "params" field, a response by
the prsence of a "result" field.

The following is an overly verbose partial mockup of a transaction
chain querying peer-stats.

[source, json]
----
{
   "mode" : 6,
   "id" : 1,
   "params" : {},
   "method" : "readstat"
}
{
   "mode" : 6,
   "id" : 1,
   "result" : {
      "answer" : {
         "associations" : [
            62414,
            62413,
            62408,
            62407,
            62406,
            62405,
            62402,
            62401,
            62400,
            62399,
            62398
         ]
      }
   }
}

{
   "mode" : 6,
   "id" : 2,
   "params" : {
      "association" : 62398
   },
   "method" : "readvar"
}
{
   "mode" : 6,
   "id" : 2,
   "result" : {
      "answer" : {
         "hmode" : 3,
         "filtdisp" : [
            14.68,
            1.5,
            2.36,
            3.45,
            4.75,
            5.19,
            6.19,
            7.12
         ],
         "keyid" : 0,
         "dstadr" : "127.0.0.1",
         "jitter" : 2.792031,
         "dstport" : 123,
         "rootdelay" : 0,
         "dispersion" : 8.528601,
         "flash" : 0,
         "filtoffset" : [
            -829.24,
            -831.68,
            -833.19,
            -832.72,
            -832.48,
            -831.32,
            -831.14,
            -830.83
         ],
         "reach" : 255,
         "mode" : 2,
         "rootdisp" : 0,
         "ppoll" : 6,
         "reftime" : 3757323811.47605,
         "delay" : 0,
         "offset" : -829.240892,
         "pmode" : 4,
         "srcadr" : "127.127.46.0",
         "precision" : -8,
         "headway" : 0,
         "hpoll" : 6,
         "rec" : 3757323811.5776,
         "xmt" : 3757323811.57759,
         "stratum" : 0,
         "srchost" : "GPSD(0)",
         "unreach" : 0,
         "srcport" : 123,
         "leap" : 0,
         "refid" : "GPSD",
         "filtdelay" : [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
         ]
      },
      "association" : 62398
   }
}


...
----

== Error notifications ==

An error notification has the following fields:

"mode":: Must be a decimal integer 7.

"id":: ID of the response to which thid corresponsds, if here is one.

"kod":: Kiss O'Death code. String. Interpreted as in RFC 5905. Optional.

"msg":: Notification to human operator. String. Optional.

== Daniel weighs in

There aren't many deficiencies in NTPv4 which can't be fixed by adding
extension fields. A change big enough to make a version bump
worthwhile would incorporate at least most of the following:

1. Drop everything other than client/server mode. Replace mode 6 with
something that runs over HTTPS on the NTS-KE port.

2. Let client and server packets be formatted differently. Achieve
data minimization by just taking unnecessary fields out of client
packets altogether. (Achieved with JSON)

3. Forbid the use of the legacy MAC field, thus fixing the hairiness
around extension parsing. (Achieved with JSON)

4. Make NTS mandatory. In the NTPv5 packet format, the version, mode,
NTS unique identifier, and (in client packets) NTS cookie come first
in plaintext, then the whole rest of the packet is encrypted.

5. Ditch the useless poll, stratum, refid, and reference timestamp
fields. Given that all of the above are implemented, origin timestamp
also becomes redundant (NTS takes the place of its anti-spoofing
role).  (Achieved with JSON)

6. Represent timestamps as days, seconds, and fractions so that the
time can be represented unambiguously during leap seconds. Make the
day field 64 bits wide so that its range comfortable exceeds the
lifespan of the solar system.  (Achieved with JSON)

7. Don't implement leap smearing in the wire protocol (servers should
always report accurate, unsmeared time), but standardize a formula for
translating NTP time into smeared UNIX time seen by other
applications. (Specified.)

== Appendix: Paths not taken

We chose a JSON-based metaprotocol to achieve the following qualities:
(a) extensibility, (b) auditability by eyeball and simple tools, (c)
avoidance of endianness or fixed-length issues in numeric
representations.

We chose *not* to optimize for least possible size of packet. In NTPv4
this was is a choice that doesn't age well. Data and transaction
volumes in real-world NTP service are low enough that the overhead
of JSON with respect to packed binary is quite affordable.

Two approaches we considered and rejected follow, with the
reasoning abbout why we rejected them.

=== NTPv4+

In this incremental approach, the NTP port number (123) would be
retained and the 48-byte v4 header would be preserved. New data
fields are passed in RFC7822 extension blocks.  The NTP version number
is not incremented; "v5" becomes a set of required extension blocks.

There can be a way to unambiguously detect v5 packets.  The stratum
field is 8 bits, but only the low five bits are used.  We can mark
v5 packets by setting the high three bits.

A difficulty with this approach is that some firewalls and routers are
known to silently discard RFC7822 extension blocks as a way of
preventing DoS attacks. However, by checking the mark described in the
previous paragraph, an ntpd can at least detect this.

=== NTPNG

In this approach, a new port number is allocated. The protocol
design is unconstrained except that it must carry the semantic
content of the v4 header minus the unused Reference Timestamp field.
The version field *is* incremented to 5.

the NTPNG payload should be structured like PNG, as a sequence of
self-describing chunks that can be retired and replaced as needed to
change payload semantics.

Though NTPNG is not constrained by the width of the v4 mode field,
the versionless semantics of a PNG-style chunk stream would confer a
desirable degree of flexibility.

The PNG standard can be found at https://www.w3.org/TR/PNG/

A chunk system appropriate for NTP can be summarized as follows:

* Each chunk begins with a four-octet big-endian length.  The length
  does not count itself.

* Each chunk continues with a 4-octet type identifier composed of
  printable ASCII characters.

* If the first character is uppercase, the chunk is *critical*; that
  is, implementations encountering a critical chunk type they do not
  recognize should treat the packet as erroneous.

* If the first character is not uppercase, the chunk is non-critical
  and may be skipped.

* Chunk content is not constrained and is interpreted based on the
  chunk type.

Note that this is not identical to PNG chunk layout; one difference is
that PNG chunks have only two-byte lengths and always end with a CRC.
This chunk system is deliberately more similar to RFC7822 extension
blocks.

The principal difficulty with this approach is that getting all the
world's firewalls to pass through a new port is far from easy.  We
rejected it on these grounds.

== References
[bibiography]

- [[[Seriot2016]]] Seriot, Nicholas; "Parsing JSON is a Minefield"
  http://seriot.ch/parsing_json.php

- [[[RFC8259]]] https://tools.ietf.org/html/rfc8259[The JavaScript
  Object Notation (JSON) Data Interchange Format]

// end

