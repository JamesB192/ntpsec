= Preliminary design notes for the NTPv5 protocol

== Why NTPv5? ==

Why an NTPv5?  Why not muddle through with NTPv4?  The principal
reason to avoid rollover cases in its time representation.  There is an
epoch turnover in 2036; it would be wise to have moved to full 64-bit
dates well before we have to deal with uncharted parts of the
software's behavior space.

NTPv4 is showing its age in other ways as well.  Its mechanism for
avoiding source loops does not play well with IPv6, and collisions
have vbeen observed in the wild.

There are various other functional capabilities that would be very
useful if they could be standardized but currently are not.  Since
we need to deal with the 32-bit-counter issues anyway, the time
is right to design a protocol which (a) includes what we now know
is needed, and (b) is extensible for future use.

== Packet metaprotocol

Every packet is led with a character '+'. This is chosen so that when
a packet analyzer for NTPv4 looks the first byte, it sees 0x02B, which
unpacks to LI:00 VN:5 MODE:3.  The version 5, which is out of band for
an NTPv4 packet, will cause the packet to be rejected by conforming
NTPv4 implementations that do not handle v5.

The Mills reference version of NTP and all codebases descended from
it (including NTPSec) *do* recognize Version 5 as out of band
and will not pass such packets to a Version 5 protocol machine.

The remainder of the packet is encoded in a strict subset of JSON
intended to avoid known edge cases decribed in <<<Seriot16>>>.  The
outermost enclosing {} is required. Trailing commas on elements are
disallowed. UTF-8 may occur but only within string literals, all else
must be 7-bit ASCII.

In the remainder of this document, packet fields will be described as
keyword-value pairs. The keyword *is* explicit in the JSON, and the
mapping is as implied in <<<RFC8259>>>.

The Appendix discusses some paths not taken and the reasons they weren't.

== The missing data: a semantic view

This document will first list these missing bits, then discuss
ways to incorporate them.

=== REFIDs

Reference IDs are used by Stratum 1 sources to identify clocks and
clock types, and by hosts at higher strata to perform loop detection.

The REFID field is four octets long, sufficient to hold an IPv4 address
for loop detection; this is inadequate for IPv6, so the reference ID of
an IPv6 host is a 4-octet hash of its actual address. AS previously
noted, hash collisions have been observed in the wild - possibly
resulting in false-positive loop detection.

The new protocol should support REFIDs at least as long as an IPv6
address (16 octets).

=== Timescale

Most servers ship UTC in seconds since the current era start.  Some
ship TAI since current era start. Some perform leap-second smearing,
some do not.

The new protocol should enable a server to advertise its timescale,
including, if applicable in its timescale, its current leap second offset.

=== Era

NTP dates are 64-bit counters based on an epoch.

The new protocol should either enable a server to ship a year identifying the
epoch on which its counters are based or ship a non-counter timestamp
format such as MJD plus seconds and fractional seconds since midnight.

=== Leap offset

Regardless of what timescale is shipped, the protocol should allow
leap second notications, warnings, and the current offset to be passed
from IERS and/or national time authorities to users.

=== NTS

The new protocol needs to (continue to) support NTS extension fields.

== Daniel weighs in

There aren't many deficiencies in NTPv4 which can't be fixed by adding
extension fields. A change big enough to make a version bump
worthwhile would incorporate at least most of the following:

1. Drop everything other than client/server mode. Replace mode 6 with
something that runs over HTTPS on the NTS-KE port.

2. Let client and server packets be formatted differently. Achieve
data minimization by just taking unnecessary fields out of client
packets altogether.

3. Forbid the use of the legacy MAC field, thus fixing the hairiness
around extension parsing.

4. Make NTS mandatory. In the NTPv5 packet format, the version, mode,
NTS unique identifier, and (in client packets) NTS cookie come first
in plaintext, then the whole rest of the packet is encrypted.

5. Ditch the useless poll, stratum, refid, and reference timestamp
fields. Given that all of the above are implemented, origin timestamp
also becomes redundant (NTS takes the place of its anti-spoofing
role).

6. Represent timestamps as days, seconds, and fractions so that the
time can be represented unambiguously during leap seconds. Make the
day field 64 bits wide so that its range comfortable exceeds the
lifespan of the solar system.

7. Don't implement leap smearing in the wire protocol (servers should
always report accurate, unsmeared time), but standardize a formula for
translating NTP time into smeared UNIX time seen by other
applications.

== Decruftifying Mode 6

It should be possible to shift a copy of mode 6 to UTF-8 JSON-RPC and
rebadge it as a new mode 7.  The following is an overly verbose
partial mockup of a transaction chain querying peer-stats.  All the
numbers should be in _decimal_ without the hexadecimal timestamps and
such.

[source, json]
----
{
   "jsonrpc" : "2.0",
   "id" : 1,
   "params" : {},
   "method" : "readstat"
}
{
   "jsonrpc" : "2.0",
   "id" : 1,
   "result" : {
      "answer" : {
         "associations" : [
            62414,
            62413,
            62408,
            62407,
            62406,
            62405,
            62402,
            62401,
            62400,
            62399,
            62398
         ]
      }
   }
}

{
   "jsonrpc" : "2.0",
   "id" : 2,
   "params" : {
      "association" : 62398
   },
   "method" : "readvar"
}
{
   "jsonrpc" : "2.0",
   "id" : 2,
   "result" : {
      "answer" : {
         "hmode" : 3,
         "filtdisp" : [
            14.68,
            1.5,
            2.36,
            3.45,
            4.75,
            5.19,
            6.19,
            7.12
         ],
         "keyid" : 0,
         "dstadr" : "127.0.0.1",
         "jitter" : 2.792031,
         "dstport" : 123,
         "rootdelay" : 0,
         "dispersion" : 8.528601,
         "flash" : 0,
         "filtoffset" : [
            -829.24,
            -831.68,
            -833.19,
            -832.72,
            -832.48,
            -831.32,
            -831.14,
            -830.83
         ],
         "reach" : 255,
         "mode" : 2,
         "rootdisp" : 0,
         "ppoll" : 6,
         "reftime" : 3757323811.47605,
         "delay" : 0,
         "offset" : -829.240892,
         "pmode" : 4,
         "srcadr" : "127.127.46.0",
         "precision" : -8,
         "headway" : 0,
         "hpoll" : 6,
         "rec" : 3757323811.5776,
         "xmt" : 3757323811.57759,
         "stratum" : 0,
         "srchost" : "GPSD(0)",
         "unreach" : 0,
         "srcport" : 123,
         "leap" : 0,
         "refid" : "GPSD",
         "filtdelay" : [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
         ]
      },
      "association" : 62398
   }
}


...
----

== Appendix: Paths not taken

We chose a JSON-based metaprotocol to achieve the following qualities:
(a) extensibility, (b) auditability by eyeball and simple tools, (c)
avoidance of endianness or fixed-length issues in numeric
representations.

We chose *not* to optimize for least possible size of packet. In NTPv4
this was is a choice that doesn't age well. Data and transaction
volumes in real-world NTP service are low enough that the overhead
of JSON with respect to packed binary is quite affordable.

=== NTPv4+

In this incremental approach, the NTP port number (123) is retained
and the 48-byte header v4 header is preserved. New data fields are
passed in RFC7822 extension blocks.  The NTP version number is
not incremented; "v5" becomes a set of required extension blocks.

There can be a way to unambiguously detect v5 packets.  The stratum
field is 8 bits, but only the low five bits are used.  We can mark
v5 packets by setting the high three bits.

A difficulty with this approach is that some firewalls and routers are
known to silently discard RFC7822 extension blocks as a way of
preventing DoS attacks. However, by checking the mark described in the
previous paragraph, an ntpd can at least detect this.

=== NTPNG

In this approach, a new port number is allocated. The protocol
design is unconstrained except that it must carry the semantic
content of the v4 header minus the unused Reference Timestamp field.
The version field *is* incremented to 5.

The principal difficulty with this approach is that getting all the
world's firewalls to pass through a new port is far from easy.  We
rejected it on these grounds.

== Payload format design for the NTPNG and Newmode cases

NTP is running out of version numbers.  The version field is only 3
bits wide.  Accordingly, the Newmode payload should be structured like
PNG, as a sequence of self-describing chunks that can be retired and
replaced as needed to change payload semantics.

Though NTPNG is not constrained by the width of the v4 mode field,
the versionless semantics of a PNG-style chunk stream would confer a
desirable degree of flexibility.

The PNG standard can be found at https://www.w3.org/TR/PNG/

A chunk system appropriate for NTP can be summarized as follows:

* Each chunk begins with a four-octet big-endian length.  The length
  does not count itself.

* Each chunk continues with a 4-octet type identifier composed of
  printable ASCII characters.

* If the first character is uppercase, the chunk is *critical*; that
  is, implementations encountering a critical chunk type they do not
  recognize should treat the packet as erroneous.

* If the first character is not uppercase, the chunk is non-critical
  and may be skipped.

* Chunk content is not constrained and is interpreted based on the
  chunk type.

Note that this is not identical to PNG chunk layout; one difference is
that PNG chunks have only two-byte lengths and always end with a CRC.
This chunk system is deliberately more similar to RFC7822 extension
blocks.


== References
[bibiography]

- [[[Seriot2016]]] Seriot, Nicholas; "Parsing JSON is a Minefield"
  http://seriot.ch/parsing_json.php

- [[[RFC8259]]] https://tools.ietf.org/html/rfc8259[The JavaScript
  Object Notation (JSON) Data Interchange Format]

// end

